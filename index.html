<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Master</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #2c3e50, #1a1a2e);
            color: #ecf0f1;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 1200px;
            gap: 20px;
        }

        .game-header {
            text-align: center;
            margin-bottom: 10px;
        }

        .game-title {
            font-size: 3.5rem;
            background: linear-gradient(45deg, #f39c12, #e74c3c);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            margin-bottom: 5px;
            letter-spacing: 2px;
        }

        .game-subtitle {
            color: #bdc3c7;
            font-size: 1.1rem;
        }

        .main-content {
            display: flex;
            gap: 30px;
            width: 100%;
            flex-wrap: wrap;
            justify-content: center;
        }

        .chess-board-container {
            flex: 1;
            min-width: 500px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .chess-board {
            width: 500px;
            height: 500px;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            border: 3px solid #7f8c8d;
            border-radius: 5px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            margin-bottom: 15px;
        }

        .square {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: pointer;
            transition: all 0.2s;
        }

        .square.light {
            background-color: #f0d9b5;
        }

        .square.dark {
            background-color: #b58863;
        }

        .square.highlight {
            background-color: rgba(52, 152, 219, 0.5) !important;
        }

        .square.selected {
            background-color: rgba(46, 204, 113, 0.5) !important;
        }

        .square.valid-move::after {
            content: '';
            width: 20px;
            height: 20px;
            background-color: rgba(52, 152, 219, 0.7);
            border-radius: 50%;
            position: absolute;
        }

        .square.capture::after {
            content: '';
            width: 100%;
            height: 100%;
            border: 5px solid rgba(231, 76, 60, 0.7);
            border-radius: 50%;
            position: absolute;
            box-sizing: border-box;
        }

        .piece {
            font-size: 2.5rem;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5);
            transition: transform 0.2s;
            z-index: 2;
        }

        .piece.white {
            color: #ecf0f1;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
        }

        .piece.black {
            color: #2c3e50;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .piece.dragging {
            transform: scale(1.1);
            z-index: 100;
        }

        .coordinates {
            display: flex;
            justify-content: space-between;
            width: 500px;
            margin-top: 5px;
        }

        .coordinate {
            color: #bdc3c7;
            font-size: 0.9rem;
            width: 62.5px;
            text-align: center;
        }

        .coordinate-vertical {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            height: 500px;
            margin-right: 5px;
        }

        .game-info {
            flex: 1;
            min-width: 300px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .players-section {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-bottom: 25px;
        }

        .player-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            display: flex;
            align-items: center;
            gap: 15px;
            transition: all 0.3s;
        }

        .player-card.active {
            background: rgba(52, 152, 219, 0.2);
            box-shadow: 0 0 15px rgba(52, 152, 219, 0.5);
        }

        .player-icon {
            font-size: 2rem;
        }

        .player-info {
            flex: 1;
        }

        .player-name {
            font-size: 1.3rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .player-stats {
            display: flex;
            gap: 15px;
            font-size: 0.9rem;
            color: #bdc3c7;
        }

        .timer {
            font-size: 1.8rem;
            font-family: monospace;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
            min-width: 90px;
            text-align: center;
        }

        .controls-section {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-bottom: 25px;
        }

        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            flex: 1;
            min-width: 120px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
        }

        .btn-secondary {
            background: linear-gradient(45deg, #2ecc71, #27ae60);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .moves-section {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            max-height: 200px;
            overflow-y: auto;
        }

        .moves-title {
            font-size: 1.2rem;
            margin-bottom: 10px;
            color: #f39c12;
            border-bottom: 2px solid #f39c12;
            padding-bottom: 5px;
        }

        .moves-list {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 5px;
            font-family: monospace;
        }

        .move-item {
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
        }

        .move-number {
            color: #bdc3c7;
        }

        .move-white {
            color: #ecf0f1;
        }

        .move-black {
            color: #95a5a6;
        }

        .status-section {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 15px;
        }

        .status-title {
            font-size: 1.2rem;
            margin-bottom: 10px;
            color: #2ecc71;
            border-bottom: 2px solid #2ecc71;
            padding-bottom: 5px;
        }

        .status-text {
            font-size: 1.1rem;
            min-height: 24px;
        }

        .promotion-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            display: none;
        }

        .promotion-options {
            background: #2c3e50;
            border-radius: 15px;
            padding: 30px;
            display: flex;
            gap: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .promotion-piece {
            font-size: 3rem;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .promotion-piece:hover {
            background: rgba(52, 152, 219, 0.3);
            transform: scale(1.1);
        }

        .ai-difficulty {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .difficulty-btn {
            padding: 8px 15px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
        }

        .difficulty-btn.active {
            background: #3498db;
        }

        .captured-pieces {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            margin-top: 10px;
            min-height: 40px;
        }

        .captured-piece {
            font-size: 1.5rem;
            opacity: 0.7;
        }

        @media (max-width: 900px) {
            .main-content {
                flex-direction: column;
                align-items: center;
            }
            
            .chess-board-container, .game-info {
                width: 100%;
            }
            
            .chess-board {
                width: 400px;
                height: 400px;
            }
            
            .coordinates {
                width: 400px;
            }
            
            .coordinate-vertical {
                height: 400px;
            }
            
            .piece {
                font-size: 2rem;
            }
        }

        @media (max-width: 500px) {
            .chess-board {
                width: 320px;
                height: 320px;
            }
            
            .coordinates {
                width: 320px;
            }
            
            .coordinate-vertical {
                height: 320px;
            }
            
            .piece {
                font-size: 1.6rem;
            }
            
            .game-title {
                font-size: 2.5rem;
            }
            
            .btn {
                min-width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            <h1 class="game-title">CHESS MASTER</h1>
            <p class="game-subtitle">Classic chess with AI opponent</p>
        </div>

        <div class="main-content">
            <div class="chess-board-container">
                <div class="coordinate-vertical">
                    <div class="coordinate">8</div>
                    <div class="coordinate">7</div>
                    <div class="coordinate">6</div>
                    <div class="coordinate">5</div>
                    <div class="coordinate">4</div>
                    <div class="coordinate">3</div>
                    <div class="coordinate">2</div>
                    <div class="coordinate">1</div>
                </div>
                <div class="chess-board" id="chessBoard"></div>
                <div class="coordinates">
                    <div class="coordinate">a</div>
                    <div class="coordinate">b</div>
                    <div class="coordinate">c</div>
                    <div class="coordinate">d</div>
                    <div class="coordinate">e</div>
                    <div class="coordinate">f</div>
                    <div class="coordinate">g</div>
                    <div class="coordinate">h</div>
                </div>
            </div>

            <div class="game-info">
                <div class="players-section">
                    <div class="player-card active" id="playerWhite">
                        <div class="player-icon">♔</div>
                        <div class="player-info">
                            <div class="player-name">White (You)</div>
                            <div class="player-stats">
                                <span>Captured: <span id="whiteCaptured">0</span></span>
                            </div>
                            <div class="captured-pieces" id="whiteCapturedPieces"></div>
                        </div>
                        <div class="timer" id="whiteTimer">10:00</div>
                    </div>
                    
                    <div class="player-card" id="playerBlack">
                        <div class="player-icon">♚</div>
                        <div class="player-info">
                            <div class="player-name">Black (AI)</div>
                            <div class="player-stats">
                                <span>Captured: <span id="blackCaptured">0</span></span>
                            </div>
                            <div class="captured-pieces" id="blackCapturedPieces"></div>
                        </div>
                        <div class="timer" id="blackTimer">10:00</div>
                    </div>
                </div>

                <div class="ai-difficulty">
                    <div class="difficulty-btn active" data-difficulty="1">Easy</div>
                    <div class="difficulty-btn" data-difficulty="2">Medium</div>
                    <div class="difficulty-btn" data-difficulty="3">Hard</div>
                </div>

                <div class="controls-section">
                    <button class="btn btn-primary" id="newGameBtn">New Game</button>
                    <button class="btn btn-secondary" id="undoBtn">Undo Move</button>
                    <button class="btn btn-danger" id="resignBtn">Resign</button>
                    <button class="btn btn-primary" id="flipBoardBtn">Flip Board</button>
                </div>

                <div class="moves-section">
                    <div class="moves-title">Move History</div>
                    <div class="moves-list" id="movesList"></div>
                </div>

                <div class="status-section">
                    <div class="status-title">Game Status</div>
                    <div class="status-text" id="statusText">White to move</div>
                </div>
            </div>
        </div>

        <div class="promotion-modal" id="promotionModal">
            <div class="promotion-options" id="promotionOptions">
                <!-- Promotion pieces will be added here -->
            </div>
        </div>
    </div>

    <script>
        // Game state and variables
        const game = {
            board: [],
            currentPlayer: 'white',
            selectedSquare: null,
            validMoves: [],
            movesHistory: [],
            capturedPieces: { white: [], black: [] },
            gameActive: true,
            aiDifficulty: 2, // 1: Easy, 2: Medium, 3: Hard
            boardFlipped: false,
            whiteTime: 600, // 10 minutes in seconds
            blackTime: 600,
            timerInterval: null,
            isCheck: false,
            isCheckmate: false,
            isStalemate: false,
            promotionPending: null
        };

        // Piece Unicode characters
        const pieceUnicode = {
            'K': '♔', 'Q': '♕', 'R': '♖', 'B': '♗', 'N': '♘', 'P': '♙',
            'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟'
        };

        // DOM elements
        const chessBoard = document.getElementById('chessBoard');
        const statusText = document.getElementById('statusText');
        const movesList = document.getElementById('movesList');
        const newGameBtn = document.getElementById('newGameBtn');
        const undoBtn = document.getElementById('undoBtn');
        const resignBtn = document.getElementById('resignBtn');
        const flipBoardBtn = document.getElementById('flipBoardBtn');
        const promotionModal = document.getElementById('promotionModal');
        const promotionOptions = document.getElementById('promotionOptions');
        const playerWhite = document.getElementById('playerWhite');
        const playerBlack = document.getElementById('playerBlack');
        const whiteTimer = document.getElementById('whiteTimer');
        const blackTimer = document.getElementById('blackTimer');
        const whiteCaptured = document.getElementById('whiteCaptured');
        const blackCaptured = document.getElementById('blackCaptured');
        const whiteCapturedPieces = document.getElementById('whiteCapturedPieces');
        const blackCapturedPieces = document.getElementById('blackCapturedPieces');
        const difficultyBtns = document.querySelectorAll('.difficulty-btn');

        // Initialize chess board
        function initBoard() {
            // Clear board
            chessBoard.innerHTML = '';
            
            // Create 8x8 board
            for (let row = 0; row < 8; row++) {
                game.board[row] = [];
                for (let col = 0; col < 8; col++) {
                    // Create square element
                    const square = document.createElement('div');
                    square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.row = game.boardFlipped ? 7 - row : row;
                    square.dataset.col = game.boardFlipped ? 7 - col : col;
                    
                    // Add click event
                    square.addEventListener('click', () => handleSquareClick(row, col));
                    
                    // Add drag and drop events
                    square.addEventListener('dragover', handleDragOver);
                    square.addEventListener('drop', handleDrop);
                    square.addEventListener('dragenter', handleDragEnter);
                    square.addEventListener('dragleave', handleDragLeave);
                    
                    chessBoard.appendChild(square);
                    game.board[row][col] = null;
                }
            }
            
            // Set up initial pieces
            setupInitialPieces();
        }

        // Set up initial chess pieces
        function setupInitialPieces() {
            // Clear all pieces first
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    game.board[row][col] = null;
                    updateSquareVisual(row, col);
                }
            }
            
            // White pieces
            game.board[7][0] = 'R'; game.board[7][1] = 'N'; game.board[7][2] = 'B'; 
            game.board[7][3] = 'Q'; game.board[7][4] = 'K'; game.board[7][5] = 'B'; 
            game.board[7][6] = 'N'; game.board[7][7] = 'R';
            for (let col = 0; col < 8; col++) game.board[6][col] = 'P';
            
            // Black pieces
            game.board[0][0] = 'r'; game.board[0][1] = 'n'; game.board[0][2] = 'b'; 
            game.board[0][3] = 'q'; game.board[0][4] = 'k'; game.board[0][5] = 'b'; 
            game.board[0][6] = 'n'; game.board[0][7] = 'r';
            for (let col = 0; col < 8; col++) game.board[1][col] = 'p';
            
            // Update all squares
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    updateSquareVisual(row, col);
                }
            }
        }

        // Update visual representation of a square
        function updateSquareVisual(row, col) {
            const squareIndex = row * 8 + col;
            const square = chessBoard.children[squareIndex];
            
            // Clear square
            square.innerHTML = '';
            
            // Remove all special classes
            square.classList.remove('highlight', 'selected', 'valid-move', 'capture');
            
            // Add piece if exists
            const piece = game.board[row][col];
            if (piece) {
                const pieceElement = document.createElement('div');
                pieceElement.className = `piece ${piece === piece.toUpperCase() ? 'white' : 'black'}`;
                pieceElement.textContent = pieceUnicode[piece];
                pieceElement.draggable = true;
                
                // Add drag events
                pieceElement.addEventListener('dragstart', handleDragStart);
                pieceElement.addEventListener('dragend', handleDragEnd);
                
                square.appendChild(pieceElement);
            }
        }

        // Convert coordinates to algebraic notation
        function toAlgebraic(row, col) {
            const letters = 'abcdefgh';
            return `${letters[col]}${8 - row}`;
        }

        // Convert algebraic notation to coordinates
        function fromAlgebraic(alg) {
            const letters = 'abcdefgh';
            const col = letters.indexOf(alg[0]);
            const row = 8 - parseInt(alg[1]);
            return { row, col };
        }

        // Get piece at position
        function getPiece(row, col) {
            if (row < 0 || row > 7 || col < 0 || col > 7) return null;
            return game.board[row][col];
        }

        // Check if piece is white
        function isWhitePiece(piece) {
            return piece && piece === piece.toUpperCase();
        }

        // Check if square is empty
        function isEmpty(row, col) {
            return game.board[row][col] === null;
        }

        // Get valid moves for a piece
        function getValidMoves(row, col) {
            const piece = getPiece(row, col);
            if (!piece) return [];
            
            const moves = [];
            const isWhite = isWhitePiece(piece);
            const pieceType = piece.toLowerCase();
            
            switch(pieceType) {
                case 'p': // Pawn
                    const direction = isWhite ? -1 : 1;
                    const startRow = isWhite ? 6 : 1;
                    
                    // Move forward one square
                    if (isEmpty(row + direction, col)) {
                        moves.push({row: row + direction, col, capture: false});
                        
                        // Move forward two squares from starting position
                        if (row === startRow && isEmpty(row + 2 * direction, col)) {
                            moves.push({row: row + 2 * direction, col, capture: false});
                        }
                    }
                    
                    // Capture diagonally
                    [-1, 1].forEach(dc => {
                        const newCol = col + dc;
                        if (newCol >= 0 && newCol < 8) {
                            const target = getPiece(row + direction, newCol);
                            if (target && isWhitePiece(target) !== isWhite) {
                                moves.push({row: row + direction, col: newCol, capture: true});
                            }
                        }
                    });
                    break;
                    
                case 'r': // Rook
                    [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dr, dc]) => {
                        for (let i = 1; i < 8; i++) {
                            const newRow = row + dr * i;
                            const newCol = col + dc * i;
                            if (newRow < 0 || newRow > 7 || newCol < 0 || newCol > 7) break;
                            
                            if (isEmpty(newRow, newCol)) {
                                moves.push({row: newRow, col: newCol, capture: false});
                            } else {
                                if (isWhitePiece(getPiece(newRow, newCol)) !== isWhite) {
                                    moves.push({row: newRow, col: newCol, capture: true});
                                }
                                break;
                            }
                        }
                    });
                    break;
                    
                case 'n': // Knight
                    [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]].forEach(([dr, dc]) => {
                        const newRow = row + dr;
                        const newCol = col + dc;
                        if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                            if (isEmpty(newRow, newCol) || isWhitePiece(getPiece(newRow, newCol)) !== isWhite) {
                                moves.push({row: newRow, col: newCol, capture: !isEmpty(newRow, newCol)});
                            }
                        }
                    });
                    break;
                    
                case 'b': // Bishop
                    [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([dr, dc]) => {
                        for (let i = 1; i < 8; i++) {
                            const newRow = row + dr * i;
                            const newCol = col + dc * i;
                            if (newRow < 0 || newRow > 7 || newCol < 0 || newCol > 7) break;
                            
                            if (isEmpty(newRow, newCol)) {
                                moves.push({row: newRow, col: newCol, capture: false});
                            } else {
                                if (isWhitePiece(getPiece(newRow, newCol)) !== isWhite) {
                                    moves.push({row: newRow, col: newCol, capture: true});
                                }
                                break;
                            }
                        }
                    });
                    break;
                    
                case 'q': // Queen (Rook + Bishop)
                    [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([dr, dc]) => {
                        for (let i = 1; i < 8; i++) {
                            const newRow = row + dr * i;
                            const newCol = col + dc * i;
                            if (newRow < 0 || newRow > 7 || newCol < 0 || newCol > 7) break;
                            
                            if (isEmpty(newRow, newCol)) {
                                moves.push({row: newRow, col: newCol, capture: false});
                            } else {
                                if (isWhitePiece(getPiece(newRow, newCol)) !== isWhite) {
                                    moves.push({row: newRow, col: newCol, capture: true});
                                }
                                break;
                            }
                        }
                    });
                    break;
                    
                case 'k': // King
                    [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([dr, dc]) => {
                        const newRow = row + dr;
                        const newCol = col + dc;
                        if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                            if (isEmpty(newRow, newCol) || isWhitePiece(getPiece(newRow, newCol)) !== isWhite) {
                                moves.push({row: newRow, col: newCol, capture: !isEmpty(newRow, newCol)});
                            }
                        }
                    });
                    break;
            }
            
            return moves;
        }

        // Check if move would leave king in check
        function isMoveSafe(fromRow, fromCol, toRow, toCol) {
            const piece = game.board[fromRow][fromCol];
            const target = game.board[toRow][toCol];
            
            // Make move temporarily
            game.board[toRow][toCol] = piece;
            game.board[fromRow][fromCol] = null;
            
            // Find king position
            const kingPiece = game.currentPlayer === 'white' ? 'K' : 'k';
            let kingRow = -1, kingCol = -1;
            
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (game.board[r][c] === kingPiece) {
                        kingRow = r;
                        kingCol = c;
                        break;
                    }
                }
                if (kingRow !== -1) break;
            }
            
            // Check if any opponent piece can attack the king
            let isSafe = true;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const opponentPiece = game.board[r][c];
                    if (opponentPiece && isWhitePiece(opponentPiece) !== (game.currentPlayer === 'white')) {
                        const moves = getValidMoves(r, c);
                        for (const move of moves) {
                            if (move.row === kingRow && move.col === kingCol) {
                                isSafe = false;
                                break;
                            }
                        }
                    }
                    if (!isSafe) break;
                }
                if (!isSafe) break;
            }
            
            // Undo temporary move
            game.board[fromRow][fromCol] = piece;
            game.board[toRow][toCol] = target;
            
            return isSafe;
        }

        // Handle square click
        function handleSquareClick(row, col) {
            if (!game.gameActive || game.currentPlayer !== 'white') return;
            
            const piece = getPiece(row, col);
            
            // If a square is already selected
            if (game.selectedSquare) {
                const [selectedRow, selectedCol] = game.selectedSquare;
                
                // Check if clicked on a valid move
                const isValidMove = game.validMoves.some(move => 
                    move.row === row && move.col === col
                );
                
                if (isValidMove) {
                    // Make the move
                    makeMove(selectedRow, selectedCol, row, col);
                    return;
                }
                
                // If clicked on another piece of the same color, select it
                if (piece && isWhitePiece(piece) === (game.currentPlayer === 'white')) {
                    selectSquare(row, col);
                    return;
                }
                
                // Deselect
                clearSelection();
                return;
            }
            
            // If clicked on a piece of current player, select it
            if (piece && isWhitePiece(piece) === (game.currentPlayer === 'white')) {
                selectSquare(row, col);
            }
        }

        // Select a square
        function selectSquare(row, col) {
            clearSelection();
            
            game.selectedSquare = [row, col];
            
            // Highlight selected square
            const squareIndex = row * 8 + col;
            chessBoard.children[squareIndex].classList.add('selected');
            
            // Get and display valid moves
            game.validMoves = getValidMoves(row, col);
            
            // Filter moves that would leave king in check
            game.validMoves = game.validMoves.filter(move => 
                isMoveSafe(row, col, move.row, move.col)
            );
            
            // Highlight valid moves
            game.validMoves.forEach(move => {
                const moveIndex = move.row * 8 + move.col;
                const moveSquare = chessBoard.children[moveIndex];
                moveSquare.classList.add(move.capture ? 'capture' : 'valid-move');
            });
        }

        // Clear selection
        function clearSelection() {
            if (game.selectedSquare) {
                const [row, col] = game.selectedSquare;
                const squareIndex = row * 8 + col;
                chessBoard.children[squareIndex].classList.remove('selected');
            }
            
            game.selectedSquare = null;
            game.validMoves = [];
            
            // Clear all move highlights
            for (let i = 0; i < 64; i++) {
                chessBoard.children[i].classList.remove('valid-move', 'capture', 'highlight');
            }
        }

        // Make a move
        function makeMove(fromRow, fromCol, toRow, toCol) {
            const piece = game.board[fromRow][fromCol];
            const target = game.board[toRow][toCol];
            
            // Record the move
            const move = {
                piece,
                from: {row: fromRow, col: fromCol},
                to: {row: toRow, col: toCol},
                captured: target,
                promotion: null
            };
            
            // Handle capture
            if (target) {
                const capturedColor = isWhitePiece(target) ? 'white' : 'black';
                game.capturedPieces[capturedColor].push(target);
                updateCapturedPieces();
            }
            
            // Move the piece
            game.board[toRow][toCol] = piece;
            game.board[fromRow][fromCol] = null;
            
            // Check for pawn promotion
            if (piece.toLowerCase() === 'p' && (toRow === 0 || toRow === 7)) {
                game.promotionPending = {row: toRow, col: toCol, piece: piece};
                showPromotionModal(piece);
                return;
            }
            
            // Complete the move
            completeMove(move);
        }

        // Complete move after promotion
        function completeMove(move) {
            // Update move history
            game.movesHistory.push(move);
            
            // Switch player
            game.currentPlayer = game.currentPlayer === 'white' ? 'black' : 'white';
            
            // Update UI
            updateBoardVisual();
            updateStatus();
            updateMoveHistory();
            updatePlayerCards();
            
            // Clear selection
            clearSelection();
            
            // Check for game end
            checkGameEnd();
            
            // If it's AI's turn, make AI move
            if (game.gameActive && game.currentPlayer === 'black') {
                setTimeout(makeAIMove, 500);
            }
        }

        // Update captured pieces display
        function updateCapturedPieces() {
            // Update counts
            whiteCaptured.textContent = game.capturedPieces.black.length;
            blackCaptured.textContent = game.capturedPieces.white.length;
            
            // Update captured pieces display
            whiteCapturedPieces.innerHTML = game.capturedPieces.black
                .map(piece => `<div class="captured-piece">${pieceUnicode[piece]}</div>`)
                .join('');
            
            blackCapturedPieces.innerHTML = game.capturedPieces.white
                .map(piece => `<div class="captured-piece">${pieceUnicode[piece]}</div>`)
                .join('');
        }

        // Show promotion modal
        function showPromotionModal(pawn) {
            const isWhite = isWhitePiece(pawn);
            const pieces = isWhite ? ['Q', 'R', 'B', 'N'] : ['q', 'r', 'b', 'n'];
            const pieceNames = ['Queen', 'Rook', 'Bishop', 'Knight'];
            
            promotionOptions.innerHTML = '';
            pieces.forEach((piece, index) => {
                const option = document.createElement('div');
                option.className = 'promotion-piece';
                option.textContent = pieceUnicode[piece];
                option.dataset.piece = piece;
                option.title = pieceNames[index];
                option.addEventListener('click', () => handlePromotion(piece));
                promotionOptions.appendChild(option);
            });
            
            promotionModal.style.display = 'flex';
        }

        // Handle promotion selection
        function handlePromotion(piece) {
            const { row, col } = game.promotionPending;
            game.board[row][col] = piece;
            promotionModal.style.display = 'none';
            
            // Get the last move and update it
            const lastMove = game.movesHistory[game.movesHistory.length - 1];
            lastMove.promotion = piece;
            
            // Complete the move
            game.currentPlayer = game.currentPlayer === 'white' ? 'black' : 'white';
            updateBoardVisual();
            updateStatus();
            updateMoveHistory();
            updatePlayerCards();
            
            if (game.gameActive && game.currentPlayer === 'black') {
                setTimeout(makeAIMove, 500);
            }
        }

        // AI move logic
        function makeAIMove() {
            if (!game.gameActive || game.currentPlayer !== 'black') return;
            
            // Get all possible moves for black
            const allMoves = [];
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = game.board[row][col];
                    if (piece && !isWhitePiece(piece)) {
                        const moves = getValidMoves(row, col);
                        moves.forEach(move => {
                            if (isMoveSafe(row, col, move.row, move.col)) {
                                allMoves.push({
                                    from: {row, col},
                                    to: {row: move.row, col: move.col},
                                    capture: move.capture,
                                    piece: piece
                                });
                            }
                        });
                    }
                }
            }
            
            if (allMoves.length === 0) {
                // No valid moves - checkmate or stalemate
                game.isCheckmate = true;
                endGame('White wins by checkmate!');
                return;
            }
            
            // Simple AI based on difficulty
            let selectedMove;
            if (game.aiDifficulty === 1) {
                // Easy: Random move
                selectedMove = allMoves[Math.floor(Math.random() * allMoves.length)];
            } else if (game.aiDifficulty === 2) {
                // Medium: Prefer captures
                const captures = allMoves.filter(move => move.capture);
                selectedMove = captures.length > 0 
                    ? captures[Math.floor(Math.random() * captures.length)]
                    : allMoves[Math.floor(Math.random() * allMoves.length)];
            } else {
                // Hard: Simple evaluation
                let bestScore = -Infinity;
                const bestMoves = [];
                
                allMoves.forEach(move => {
                    let score = 0;
                    
                    // Prefer captures
                    if (move.capture) {
                        const target = game.board[move.to.row][move.to.col];
                        // Piece values
                        const pieceValues = { 'p': 1, 'n': 3, 'b': 3, 'r': 5, 'q': 9, 'k': 0 };
                        score += pieceValues[target.toLowerCase()] || 0;
                    }
                    
                    // Center control
                    const centerDist = Math.abs(move.to.row - 3.5) + Math.abs(move.to.col - 3.5);
                    score += (14 - centerDist) * 0.1;
                    
                    // Prefer moving developed pieces
                    if (move.piece.toLowerCase() === 'p' && move.from.row === 1) {
                        score += 0.5; // Encourage pawn advancement
                    }
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestMoves.length = 0;
                        bestMoves.push(move);
                    } else if (score === bestScore) {
                        bestMoves.push(move);
                    }
                });
                
                selectedMove = bestMoves[Math.floor(Math.random() * bestMoves.length)];
            }
            
            // Make the AI move
            makeMove(selectedMove.from.row, selectedMove.from.col, 
                    selectedMove.to.row, selectedMove.to.col);
        }

        // Update game status
        function updateStatus() {
            let status = game.currentPlayer === 'white' ? 'White to move' : 'Black to move';
            
            if (game.isCheckmate) {
                status = game.currentPlayer === 'white' ? 'Black wins by checkmate!' : 'White wins by checkmate!';
            } else if (game.isStalemate) {
                status = 'Stalemate!';
            } else if (game.isCheck) {
                status = `${game.currentPlayer === 'white' ? 'White' : 'Black'} is in check!`;
            }
            
            statusText.textContent = status;
        }

        // Update move history display
        function updateMoveHistory() {
            movesList.innerHTML = '';
            
            for (let i = 0; i < game.movesHistory.length; i += 2) {
                const moveNumber = Math.floor(i / 2) + 1;
                const whiteMove = game.movesHistory[i];
                const blackMove = game.movesHistory[i + 1];
                
                const moveItem = document.createElement('div');
                moveItem.className = 'move-item';
                
                let moveText = `<span class="move-number">${moveNumber}.</span>`;
                
                if (whiteMove) {
                    const from = toAlgebraic(whiteMove.from.row, whiteMove.from.col);
                    const to = toAlgebraic(whiteMove.to.row, whiteMove.to.col);
                    moveText += `<span class="move-white"> ${from}${whiteMove.captured ? 'x' : '-'}${to}</span>`;
                }
                
                if (blackMove) {
                    const from = toAlgebraic(blackMove.from.row, blackMove.from.col);
                    const to = toAlgebraic(blackMove.to.row, blackMove.to.col);
                    moveText += `<span class="move-black"> ${from}${blackMove.captured ? 'x' : '-'}${to}</span>`;
                }
                
                moveItem.innerHTML = moveText;
                movesList.appendChild(moveItem);
            }
            
            // Scroll to bottom
            movesList.scrollTop = movesList.scrollHeight;
        }

        // Update player cards
        function updatePlayerCards() {
            if (game.currentPlayer === 'white') {
                playerWhite.classList.add('active');
                playerBlack.classList.remove('active');
            } else {
                playerWhite.classList.remove('active');
                playerBlack.classList.add('active');
            }
        }

        // Check for game end
        function checkGameEnd() {
            // Check for checkmate or stalemate
            let hasValidMove = false;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = game.board[row][col];
                    if (piece && isWhitePiece(piece) === (game.currentPlayer === 'white')) {
                        const moves = getValidMoves(row, col);
                        for (const move of moves) {
                            if (isMoveSafe(row, col, move.row, move.col)) {
                                hasValidMove = true;
                                break;
                            }
                        }
                    }
                    if (hasValidMove) break;
                }
                if (hasValidMove) break;
            }
            
            if (!hasValidMove) {
                // Check if king is in check
                let isKingInCheck = false;
                const kingPiece = game.currentPlayer === 'white' ? 'K' : 'k';
                
                // Find king
                kingSearch: for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        if (game.board[row][col] === kingPiece) {
                            // Check if any opponent piece can attack the king
                            for (let r = 0; r < 8; r++) {
                                for (let c = 0; c < 8; c++) {
                                    const opponentPiece = game.board[r][c];
                                    if (opponentPiece && isWhitePiece(opponentPiece) !== (game.currentPlayer === 'white')) {
                                        const moves = getValidMoves(r, c);
                                        for (const move of moves) {
                                            if (move.row === row && move.col === col) {
                                                isKingInCheck = true;
                                                break kingSearch;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                if (isKingInCheck) {
                    game.isCheckmate = true;
                    endGame(`${game.currentPlayer === 'white' ? 'Black' : 'White'} wins by checkmate!`);
                } else {
                    game.isStalemate = true;
                    endGame('Stalemate!');
                }
            }
        }

        // End game
        function endGame(message) {
            game.gameActive = false;
            statusText.textContent = message;
            
            if (game.timerInterval) {
                clearInterval(game.timerInterval);
                game.timerInterval = null;
            }
        }

        // Update board visual
        function updateBoardVisual() {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    updateSquareVisual(row, col);
                }
            }
        }

        // Start new game
        function newGame() {
            // Reset game state
            game.currentPlayer = 'white';
            game.selectedSquare = null;
            game.validMoves = [];
            game.movesHistory = [];
            game.capturedPieces = { white: [], black: [] };
            game.gameActive = true;
            game.isCheck = false;
            game.isCheckmate = false;
            game.isStalemate = false;
            game.promotionPending = null;
            game.whiteTime = 600;
            game.blackTime = 600;
            
            // Reset timers
            whiteTimer.textContent = '10:00';
            blackTimer.textContent = '10:00';
            
            // Stop existing timer
            if (game.timerInterval) {
                clearInterval(game.timerInterval);
                game.timerInterval = null;
            }
            
            // Start timer
            game.timerInterval = setInterval(updateTimers, 1000);
            
            // Reset board
            setupInitialPieces();
            
            // Update UI
            updateStatus();
            updateMoveHistory();
            updatePlayerCards();
            updateCapturedPieces();
            
            // Hide promotion modal if visible
            promotionModal.style.display = 'none';
        }

        // Update timers
        function updateTimers() {
            if (!game.gameActive) return;
            
            if (game.currentPlayer === 'white') {
                game.whiteTime--;
                if (game.whiteTime <= 0) {
                    endGame('Black wins on time!');
                    return;
                }
            } else {
                game.blackTime--;
                if (game.blackTime <= 0) {
                    endGame('White wins on time!');
                    return;
                }
            }
            
            // Update timer displays
            whiteTimer.textContent = formatTime(game.whiteTime);
            blackTimer.textContent = formatTime(game.blackTime);
        }

        // Format time as MM:SS
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        // Undo last move
        function undoMove() {
            if (game.movesHistory.length === 0 || !game.gameActive) return;
            
            // Get last move
            const lastMove = game.movesHistory.pop();
            
            // Undo the move
            game.board[lastMove.from.row][lastMove.from.col] = lastMove.piece;
            game.board[lastMove.to.row][lastMove.to.col] = lastMove.captured;
            
            // Remove from captured pieces if there was a capture
            if (lastMove.captured) {
                const capturedColor = isWhitePiece(lastMove.captured) ? 'white' : 'black';
                game.capturedPieces[capturedColor].pop();
                updateCapturedPieces();
            }
            
            // Switch player back
            game.currentPlayer = game.currentPlayer === 'white' ? 'black' : 'white';
            
            // Update UI
            updateBoardVisual();
            updateStatus();
            updateMoveHistory();
            updatePlayerCards();
            
            // Clear selection
            clearSelection();
        }

        // Flip board
        function flipBoard() {
            game.boardFlipped = !game.boardFlipped;
            initBoard();
        }

        // Drag and Drop handlers
        let draggedPiece = null;
        let draggedFrom = null;

        function handleDragStart(e) {
            if (!game.gameActive || game.currentPlayer !== 'white') {
                e.preventDefault();
                return;
            }
            
            const pieceElement = e.target;
            const square = pieceElement.parentElement;
            const row = parseInt(square.dataset.row);
            const col = parseInt(square.dataset.col);
            
            const piece = game.board[row][col];
            if (!piece || isWhitePiece(piece) !== (game.currentPlayer === 'white')) {
                e.preventDefault();
                return;
            }
            
            draggedPiece = pieceElement;
            draggedFrom = { row, col };
            
            // Add dragging class after a short delay
            setTimeout(() => pieceElement.classList.add('dragging'), 0);
            
            // Set drag image
            e.dataTransfer.setData('text/plain', '');
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleDragEnd(e) {
            if (draggedPiece) {
                draggedPiece.classList.remove('dragging');
                draggedPiece = null;
                draggedFrom = null;
            }
            
            // Remove highlight from all squares
            for (let i = 0; i < 64; i++) {
                chessBoard.children[i].classList.remove('highlight');
            }
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }

        function handleDragEnter(e) {
            e.preventDefault();
            const square = e.target.classList.contains('square') ? e.target : e.target.parentElement;
            if (square.classList.contains('square')) {
                square.classList.add('highlight');
            }
        }

        function handleDragLeave(e) {
            const square = e.target.classList.contains('square') ? e.target : e.target.parentElement;
            if (square.classList.contains('square')) {
                square.classList.remove('highlight');
            }
        }

        function handleDrop(e) {
            e.preventDefault();
            
            if (!draggedPiece || !draggedFrom || !game.gameActive || game.currentPlayer !== 'white') return;
            
            const toSquare = e.target.classList.contains('square') ? e.target : e.target.parentElement;
            const toRow = parseInt(toSquare.dataset.row);
            const toCol = parseInt(toSquare.dataset.col);
            
            // Check if move is valid
            const validMoves = getValidMoves(draggedFrom.row, draggedFrom.col);
            const isValidMove = validMoves.some(move => 
                move.row === toRow && move.col === toCol && 
                isMoveSafe(draggedFrom.row, draggedFrom.col, toRow, toCol)
            );
            
            if (isValidMove) {
                makeMove(draggedFrom.row, draggedFrom.col, toRow, toCol);
            }
            
            // Remove highlight
            toSquare.classList.remove('highlight');
        }

        // Event listeners
        newGameBtn.addEventListener('click', newGame);
        undoBtn.addEventListener('click', undoMove);
        resignBtn.addEventListener('click', () => {
            if (game.gameActive) {
                endGame(`${game.currentPlayer === 'white' ? 'Black' : 'White'} wins by resignation!`);
            }
        });
        flipBoardBtn.addEventListener('click', flipBoard);

        // Difficulty selection
        difficultyBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                difficultyBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                game.aiDifficulty = parseInt(btn.dataset.difficulty);
            });
        });

        // Initialize game
        newGame();
    </script>
</body>
</html>